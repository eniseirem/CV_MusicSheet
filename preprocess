import sys
import cv2 as cv
import numpy as np
from matplotlib import pyplot as plt
from collections import Counter
from copy import deepcopy
from PIL import Image
#from midiutil.MidiFile import MIDIFile

####### this is the sample code from the given source.


def show_wait_destroy(winname, img):
    cv.imwrite(str(winname)+".png", img)
    cv.imshow(winname, img)
    cv.moveWindow(winname, 500, 0)
    cv.waitKey(0)
    cv.destroyWindow(winname)


inp_sheet = cv.imread("data/sample.png", cv.IMREAD_COLOR)
corners1 = np.copy(inp_sheet)
inp = np.copy(inp_sheet)

if len(inp_sheet.shape) != 2:
    gray = cv.cvtColor(inp_sheet, cv.COLOR_BGR2GRAY)
else:
    gray = inp_sheet

#show_wait_destroy("gray", gray)

# Apply adaptiveThreshold at the bitwise_not of gray, notice the ~ symbol
gray = cv.bitwise_not(gray)
bw = cv.adaptiveThreshold(gray, 255, cv.ADAPTIVE_THRESH_MEAN_C, cv.THRESH_BINARY, 15, -2)
# Show binary image
#show_wait_destroy("binary", bw)

# Create the images that will use to extract the horizontal and vertical lines
horizontal = np.copy(bw)
vertical = np.copy(bw)

# Specify size on horizontal axis
cols = horizontal.shape[1]
horizontal_size = cols // 30
# Create structure element for extracting horizontal lines through morphology operations
horizontalStructure = cv.getStructuringElement(cv.MORPH_RECT, (horizontal_size, 1))
# Apply morphology operations
horizontal = cv.erode(horizontal, horizontalStructure)
horizontal = cv.dilate(horizontal, horizontalStructure)
# Show extracted horizontal lines
#show_wait_destroy("horizontal", horizontal)

# Remove horizontal
horizontal_kernel = cv.getStructuringElement(cv.MORPH_RECT, (25,1))
detected_lines = cv.morphologyEx(bw, cv.MORPH_OPEN, horizontal_kernel, iterations=2)
cnts = cv.findContours(detected_lines, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE)
cnts = cnts[0] if len(cnts) == 2 else cnts[1]
for c in cnts:
    cv.drawContours(inp_sheet, [c], -1, (255,255,255), 2)


# Repair image
repair_kernel = cv.getStructuringElement(cv.MORPH_RECT, (1,6))
result = 255 - cv.morphologyEx(255 - inp_sheet, cv.MORPH_CLOSE, repair_kernel, iterations=1)

#show_wait_destroy("removed lines", result)
circle_inp = np.copy(bw)

img_blur = cv.medianBlur(gray, 5)
#show_wait_destroy("removed lines", img_blur)

circles = cv.HoughCircles(img_blur, cv.HOUGH_GRADIENT, 1, inp_sheet.shape[0]/64, param1=200, param2=10, minRadius=5, maxRadius=30)
# Draw detected circles
if circles is not None:
    circles = np.uint16(np.around(circles))
    for i in circles[0, :]:
        # Draw outer circle
        cv.circle(inp_sheet, (i[0], i[1]), i[2], (0, 255, 0), 2)
        # Draw inner circle
        cv.circle(inp_sheet, (i[0], i[1]), 2, (0, 0, 255), 3)

#show_wait_destroy("circles", inp_sheet)


#detecting corners
def corners(pic,detect, name):
    blur = cv.GaussianBlur(detect, (3, 3), 0)
    thresh = cv.threshold(blur, 220, 255, cv.THRESH_BINARY_INV)[1]

    x, y, w, h = cv.boundingRect(thresh)
   # left = (x, np.argmax(thresh[:, x]))
    #right = (x + w - 1, np.argmax(thresh[:, x + w - 1]))
    #top = (np.argmax(thresh[y, :]), y)
   # bottom = (np.argmax(thresh[y + h - 1, :]), y + h - 1)
    me2 = (np.argmax(thresh[y, :]), y) #leftup
    me1 = (x + w - 1, y+h-1) #rightdown
    me4 = (x + w - 1, y) #rightupmost
   # me3 = ( np.argmax(thresh[x + w - 1, :]),np.argmax(thresh[:, y])) #rightupmost
   # me3 = (np.argmax(thresh[y, :]), y + h - 1) #leftdown
    me5 = (x, np.argmax(thresh[:, x])) #leftdown
    # cv.drawContours(corners1, [c], -1, (36, 255, 12), 2)
    #cv.circle(pic, left, 8, (0, 50, 255), -1)
    #cv.circle(pic, right, 8, (0, 50, 255), -1) #
   # cv.circle(pic, top, 8, (255, 50, 0), -1)
   # cv.circle(pic, bottom, 8, (255, 50, 0), -1)
    cv.circle(pic, me2, 8, (255, 255, 0), -1)
    cv.circle(pic, me1, 8, (255, 255, 0), -1)
    cv.circle(pic, me4, 8, (255, 255, 0), -1)
   # cv.circle(pic, me3, 8, (255, 255, 0), -1)
    cv.circle(pic, me5, 8, (255, 255, 0), -1)
    #print('left: {}'.format(left))
    #print('right: {}'.format(right))
    #print('top: {}'.format(top))
    #print('bottom: {}'.format(bottom))
    show_wait_destroy(name, pic)
    return pic, me1, me2, me4, me5, x,y,w,h

def cut(pic, x,y,w,h, name):
    roi = pic[y:y + h, x:x + w]
    roi = cv.resize(roi, (w, h))
    show_wait_destroy(name, roi)

lines = cv.bitwise_not(horizontal)
corners1, left, right, top, bottom, x, y, w, h= corners(corners1,lines,"corners")
point_inp = np.array([left,right,top,bottom], dtype=np.float32)
#
# #cut(corners1,x,y,w,h,"cutpic")
# blur = cv.GaussianBlur(lines, (3, 3), 0)
# thresh = cv.threshold(blur, 220, 255, cv.THRESH_BINARY_INV)[1]
# corners = cv.goodFeaturesToTrack(thresh, 2, 0.01, 10)
# print(corners)
# # convert corners values to integer
# # So that we will be able to draw circles on them
# corners = np.int0(corners)
#
# # draw red color circles on all corners
# for i in corners:
#     x, y = i.ravel()
#     cv.circle(corners1, (x, y), 8, (255, 0, 0), -1)
#     print(i)
# # resulting image
# show_wait_destroy("hehe2",corners1)
# # De-allocate any associated memory usage
# cv.waitKey(0)

#%%reference pic
#

H=inp.shape[0]
W=inp.shape[1]
dst = np.array([[0, 0],   [W, 0],   [W, H],    [0, H]], np.float32)
h, status = cv.findHomography(point_inp, dst) # src, dst
dst = cv.warpPerspective(inp, h, (W,H)) #wraped image

cv.waitKey(0)
show_wait_destroy("hehye", dst)
